# Инструкция по работе с git

## Что это и для чего нужна система контроля версий?
Программное обеспечение контроля версий отслеживает все вносимые в код изменения в специальной базе данных. При обнаружении ошибки разработчики могут вернуться назад и выполнить сравнение с более ранними версиями кода для исправления ошибок, сводя к минимуму проблемы для всех участников команды.

### Что такое система контроля версий?
Сиситема контроля версий - это один из ключевых инструментов разработки, позволяющий наладить непрерывную интеграцию и развертывание ПО в процессе работы над проектом.

### Для чего нужна система контроля версий
Система контроля версий помогает разработчикам параллельно работать над проектом, не мешать друг другу и добавлять в master-ветку только качественный код.

## Установка git и VSCode на ваш ПК.
Чтобы установить Git и VS Code на Windows можно воспользоваться следующими ссылками:

- Git: https://git-scm.com/download/win

- VS Code: https://code.visualstudio.com/docs?dv=win

### Установка VSCode на ваш ПК.
1. Скачайте [установщик Visual Studio Code](https://code.visualstudio.com/docs?dv=win) для Windows.
2. После загрузки запустите установщик (VSCodeUserSetup-{version}.exe). 
3. По умолчанию VS Code устанавливается в папке  .C:\Users\{Username}\AppData\Local\Programs\Microsoft VS Code
### Установка git на ваш ПК
Для установки Git на Windows достаточно воспользоваться ссылкой: https://git-scm.com/download/win
Для дополнительной информации можно перейти по ссылке: https://gitforwindows.org/
#### Первая настройка git
Теперь, когда Git установлен в вашей системе, самое время настроить среду для работы с Git под себя. Это нужно сделать только один раз — при обновлении версии Git настройки сохранятся. Но, при необходимости, вы можете поменять их в любой момент, выполнив те же команды снова.

В состав Git входит утилита git config, которая позволяет просматривать и настраивать параметры, контролирующие все аспекты работы Git, а также его внешний вид. Эти параметры могут быть сохранены в трёх местах:

1. Файл [path]/etc/gitconfig содержит значения, общие для всех пользователей системы и для всех их репозиториев. Если при запуске git config указать параметр --system, то параметры будут читаться и сохраняться именно в этот файл. Так как этот файл является системным, то вам потребуются права суперпользователя для внесения изменений в него.

2. Файл ~/.gitconfig или ~/.config/git/config хранит настройки конкретного пользователя. Этот файл используется при указании параметра --global и применяется ко всем репозиториям, с которыми вы работаете в текущей системе.

3. Файл config в каталоге Git (т. е. .git/config) репозитория, который вы используете в данный момент, хранит настройки конкретного репозитория. Вы можете заставить Git читать и писать в этот файл с помощью параметра --local, но на самом деле это значение по умолчанию. Неудивительно, что вам нужно находиться где-то в репозитории Git, чтобы эта опция работала правильно.

Настройки на каждом следующем уровне подменяют настройки из предыдущих уровней, то есть значения в .git/config перекрывают соответствующие значения в  [path]/etc/gitconfig.

В системах семейства Windows Git ищет файл .gitconfig в каталоге $HOME (C:\Users\$USER для большинства пользователей). Кроме того, Git ищет файл [path]/etc/gitconfig, но уже относительно корневого каталога MSys, который находится там, куда вы решили установить Git при запуске инсталлятора.

Если вы используете Git для Windows версии 2.х или новее, то так же обрабатывается файл конфигурации уровня системы, который имеет путь C:\Documents and Settings\All Users\Application Data\Git\config в Windows XP или C:\ProgramData\Git\config в Windows Vista и новее. Этот файл может быть изменён только командой git config -f <file>, запущенной с правами администратора.

Чтобы посмотреть все установленные настройки и узнать где именно они заданы, используйте команду:

$ git config --list --show-origin

- **Имя пользователя**

Первое, что вам следует сделать после установки Git — указать ваше имя и адрес электронной почты. Это важно, потому что каждый коммит в Git содержит эту информацию, и она включена в коммиты, передаваемые вами, и не может быть далее изменена (перед такими командами следует добавлять знак "$"):

 git config --global user.name "John Doe"(пример)
 git config --global user.email johndoe@example.com(пример)

Опять же, если указана опция --global, то эти настройки достаточно сделать только один раз, поскольку в этом случае Git будет использовать эти данные для всего, что вы делаете в этой системе. Если для каких-то отдельных проектов вы хотите указать другое имя или электронную почту, можно выполнить эту же команду без параметра --global в каталоге с нужным проектом.

Многие GUI-инструменты предлагают сделать это при первом запуске.

- **Выбор редактора**
Теперь, когда вы указали своё имя, самое время выбрать текстовый редактор, который будет использоваться, если будет нужно набрать сообщение в Git. По умолчанию Git использует стандартный редактор вашей системы, которым обычно является Vim. Если вы хотите использовать другой текстовый редактор, например, Emacs, можно проделать следующее:

$ git config --global core.editor emacs
В системе Windows следует указывать полный путь к исполняемому файлу при установке другого текстового редактора по умолчанию. Пути могут отличаться в зависимости от того, как работает инсталлятор.

В случае с Notepad++, популярным редактором, скорее всего вы захотите установить 32-битную версию, так как 64-битная версия ещё не поддерживает все плагины. Если у вас 32-битная Windows или 64-битный редактор с 64-битной системой, то выполните следующее:

$ git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"

- **Настройка ветки по умолчанию**

Когда вы инициализируете репозиторий командой git init, Git создаёт ветку с именем master по умолчанию. Начиная с версии 2.28, вы можете задать другое имя для создания ветки по умолчанию.

Например, чтобы установить имя main для вашей ветки по умолчанию, выполните следующую команду:

$ git config --global init.defaultBranch main

- **Проверка настроек** 

Если вы хотите проверить используемую конфигурацию, можете использовать команду git config --list, чтобы показать все настройки, которые Git найдёт:

$ git config --list
user.name=John Doe
user.email=johndoe@example.com
color.status=auto
color.branch=auto
color.interactive=auto
color.diff=auto
...
Некоторые ключи (названия) настроек могут отображаться несколько раз, потому что Git читает настройки из разных файлов (например, из /etc/gitconfig и ~/.gitconfig). В таком случае Git использует последнее значение для каждого ключа.

Также вы можете проверить значение конкретного ключа, выполнив git config <key>:

$ git config user.name
John Doe

## Создание и базовая работа с локальным репозиторием.
Обычно вы получаете репозиторий Git одним из двух способов:

1. Вы можете взять локальный каталог, который в настоящее время не находится под версионным контролем, и превратить его в репозиторий Git, либо

2. Вы можете клонировать существующий репозиторий Git из любого места.

В обоих случаях вы получите готовый к работе Git репозиторий на вашем компьютере.

- **Создание репозитория в существующем каталоге**

Если у вас уже есть проект в каталоге, который не находится под версионным контролем Git, то для начала нужно перейти в него. Если вы не делали этого раньше, то для разных операционных систем это выглядит по-разному:

- **для Linux:**

$ cd /home/user/my_project

- **для macOS:**

$ cd /Users/user/my_project

- **для Windows:**

$ cd C:/Users/user/my_project
а затем выполните команду:

$ git init
Эта команда создаёт в текущем каталоге новый подкаталог с именем .git, содержащий все необходимые файлы репозитория — структуру Git репозитория. На этом этапе ваш проект ещё не находится под версионным контролем. Подробное описание файлов, содержащихся в только что созданном вами каталоге .git, приведено в главе Git изнутри

Если вы хотите добавить под версионный контроль существующие файлы (в отличие от пустого каталога), вам стоит добавить их в индекс и осуществить первый коммит изменений. Добиться этого вы сможете запустив команду git add несколько раз, указав индексируемые файлы, а затем выполнив git commit:

$ git add *.c
$ git add LICENSE
$ git commit -m 'Initial project version'

- **Начальная работа с Git**

1. Выбор ветки по умолчанию.

Основная ветка автоматически будет названа master. Изменить это (в нашем случае задав ветку main) можно так:

> git config --global init.defaultBranch main

2. Работа в репозитории.

Как правило, есть два варианта начать работу с репозиторием Git:

- Можно выбрать локальный каталог и создать новый репозиторий в нем.
- Можно клонировать существующий репозиторий с локального компьютера или сервера. Обычно проекты клонируются именно с сервера.

Если у вас на компьютере уже есть рабочий проект, но еще не назначен контроль версий, то нужно сначала перейти в каталог проекта.

Windows:

> cd C:/Users/user/SomeConsoleApp

Инициализируем репозиторий:

> git init

Команда создаст каталог с именем .git, в котором будут храниться структурные файлы репозитория. 

И, наконец, нужно добавить под контроль версий все существующие файлы командой git add . (точка в конце важна!). Можно добавлять и по одному файлу, с помощью git add <имя файла>. 

Заодно создадим начальный коммит командой git commit:

> git add readme.md

> git commit -m 'Initial project version'

- **Файл .gitignore**

Как упоминалось ранее, в рабочий каталог могут попадать файлы, которые вам бы не хотелось отправлять на сервер. Это и документы с вашими экспериментами или образцами, и автоматически генерируемые части проекта, актуальные только на вашем компьютере. Git может полностью игнорировать их, если создать в рабочем каталоге файл с названием **.gitignore** и внести в него все имена ненужных файлов и папок.

Открывать файл можно в любом текстовом редакторе. Обычно удобнее не перечислять абсолютно все имена (которые к тому же всегда известны), а воспользоваться подобными инструкциями:

>/bin

>/obj

>*.pdb

>*.exe

Если прописать такое содержимое файла **.gitignore**, то репозиторий git будет полностью игнорировать папки **/bin** и **/obj**, а также любые файлы с расширениями **.pdb** и **.exe**, хранящиеся в вашем рабочем каталоге.

Рекомендуется создавать **.gitignore** до первой отправки вашего проекта в удаленный репозиторий, чтобы на сервер не попало никаких лишних файлов и каталогов. Разумеется, важно проверить, чтобы в **.gitignore** не были упомянуты критичные для проекта файлы, иначе у других участников команды возникнут проблемы после следующего обновления.

- **Управление удаленными репозиториями** 

Просмотреть список текущих онлайн-репозиториев можно командой **git remote**. Добавить другие — с помощью команды **git remote add <shortname> <url>**, например:

- **Отправка изменений в удаленный репозиторий (Push)**

На вашем компьютере есть проект со внесенными изменениями, но вы хотите поделиться новой версией со всей командой. 

Команда для отправки изменений на сервер такова: **git push <remote-name> <branch-name>**. Если ваша ветка называется master, то команда для отправки коммитов станет такой:

> git push origin master

-**Получение изменений из репозитория (Pull)**

Самый простой и быстрый способ получить изменения с сервера — выполнить команду **git pull**, которая извлечет (*fetch*) данные с сервера и попытается встроить/объединить (*merge*) их с вашей локальной версией проекта. 

На этом этапе могут возникать конфликты версий, когда несколько человек поработали над одними и теми же файлами в проекте и сохранили свои изменения. Избежать этого можно, если изолировать части проекта, поручив работу над одной частью только одному человеку. Разумеется, на практике это не всегда выполнимо, поэтому в Git есть инструменты для разрешения конфликтов версий. Они будут рассмотрены далее.

-**Создание веток и переключение между ними**

Создадим две дополнительные ветки Dev и Test (например, одна может пригодиться для процесса разработки, а другая — для запуска в тестирование). Введем команду **git branch <branch-name>** дважды с разными аргументами:

>git branch Dev

>git branch Test

Ветки созданы, но мы по-прежнему работаем в master. Для переключения на другую нужно выполнить **git checkout <branch-name>**:

>git checkout Dev

Switched to branch ‘Dev’

Your branch is up to date with ‘origin/Dev’.

Внесем некоторые изменения в файл README.md и зафиксируем их, чтобы они отразились в ветке Dev:

>git add .

>git commit -m “dev readme changed”
[Dev #####] dev readme changed
1 file changed, 2 insertions(+)

- **Слияние веток (merge)**

Работа над проектами часто ведется в несколько этапов, им могут соответствовать ветки (в нашем примере Dev → Test → master). Отдельные ветки могут создаваться для срочного исправления багов, быстрого добавления временных функций, для делегирования части работы другому отделу и т. д. Предположим, что нужно применить изменения из ветки *Dev*, внеся их в *master*. Перейдем в *master* и выполним команду **git merge <source-branch>**:

>git merge Dev
Updating #####..#####
Fast-forward
README.md | 2 +-
1 file changed, 1 insertion(+), 1 deletion(-)


### Что такое репозиторий и инструкция по созданию локальных репозиториев.

**Репозиторий Git** — это папка, в которой в Git отслеживаются изменения. На компьютере может быть любое количество репозиториев, каждый из которых хранится в собственной папке. Каждый репозиторий Git в системе не зависит, поэтому изменения, сохраненные в одном репозитории Git, не влияют на содержимое другого. Репозиторий Git содержит каждую версию каждого файла, сохраненного в репозитории.

- **Создание нового репозитория**

Как мы отметили ранее, git хранит свои файлы и историю прямо в папке проекта. Чтобы создать новый репозиторий, нам нужно открыть терминал, зайти в папку нашего проекта и выполнить команду init. Это включит приложение в этой конкретной папке и создаст скрытую директорию .git, где будет храниться история репозитория и настройки.
Создайте на рабочем столе папку под названием git_exercise. Для этого в окне терминала введите:

> $ mkdir Desktop/git_exercise/

> $ cd Desktop/git_exercise/

> $ git init

Командная строка должна вернуть что-то вроде:

> Initialized empty Git repository in /home/user/Desktop/git_exercise/.git/

Это значит, что наш репозиторий был успешно создан, но пока что пуст. Теперь создайте текстовый файл под названием **hello.txt** и сохраните его в директории **git_exercise**.

### Базовая работа с локальным репозиторием. 

- **Базовые команды**

**git init — создание репозитория**
Команда git init создает в директории пустой репозиторий в виде директории .git, где и будет в дальнейшем храниться вся информация об истории коммитов, тегах — о ходе разработки проекта:

>mkdir project-dir

>cd project-dir

>git init


- **git add и git rm — индексация изменений**
Следующее, что нужно знать — команда git add. Она позволяет внести в индекс — временное хранилище — изменения, которые затем войдут в коммит.

Индексирует измененный файл, либо оповещение о создании нового:

>git add EDITEDFILE


Вносит в индекс все изменения, включая новые файлы:

>git add .


Из индекса и дерева проекта одновременно файл можно удалить командой git rm.

Удаляет из индекса и дерева проекта отдельные файлы:

>git rm FILE1 FILE2


Хороший пример удаления из документации к git, удаляются сразу все файлы txt из папки:

>git rm Documentation/\*.txt


Вносит в индекс все удаленные файлы:

>git rm -r --cached .


Сбросить весь индекс или удалить из него изменения определенного файла можно командой git reset:

>git reset


Удаляет из индекса конкретный файл:

>git reset — EDITEDFILE


Команда git reset используется не только для сбрасывания индекса, поэтому дальше ей будет уделено гораздо больше внимания.

- **git status — состояние проекта, измененные и не добавленные файлы, индексированные файлы**

Команду git status, пожалуй, можно считать самой часто используемой наряду с командами коммита и индексации. Она выводит информацию обо всех изменениях, внесенных в дерево директорий проекта по сравнению с последним коммитом рабочей ветки; отдельно выводятся внесенные в индекс и неиндексированные файлы. Использовать ее крайне просто:

>git status

Кроме того, git status указывает на файлы с неразрешенными конфликтами слияния и файлы, игнорируемые git.

- **git commit — совершение коммита**

Коммит — базовое понятие во всех системах контроля версий, поэтому совершаться он должен легко и по возможности быстро. В простейшем случае достаточно после индексации набрать:

>git commit


Если индекс не пустой, то на его основе будет совершен коммит, после чего пользователя попросят прокомментировать вносимые изменения вызовом команды edit. Сохраняемся, и вуаля! Коммит готов. Есть несколько ключей, упрощающих работу с git commit.

Совершает коммит, автоматически индексируя изменения в файлах проекта. Новые файлы при этом индексироваться не будут! Удаление же файлов будет учтено:

>git commit -a


Комментирует коммит прямо из командной строки вместо текстового редактора:

>git commit -m «commit comment»


Вносит в индекс и создаёт коммит на основе изменений единственного файла:

>git commit FILENAME

- **git log — разнообразная информация о коммитах в целом**
Иногда требуется получить информацию об истории коммитов; коммитах, изменивших отдельный файл; коммитах за определенный отрезок времени и так далее. Для этих целей используется команда git log.

Простейший пример использования, в котором приводится короткая справка по всем коммитам, коснувшимся активной в настоящий момент ветки (о ветках и ветвлении подробно узнать можно ниже, в разделе «Ветвления и слияния»):

>git log

Получает подробную информацию о каждом в виде патчей по файлам из коммитов можно, добавив ключ -p (или -u):

>git log -p

- **git diff — отличия между деревьями проекта, коммитами и т.д.**
Своего рода подмножеством команды git log можно считать команду git diff, определяющую изменения между объектами в проекте - деревьями (файлов и директорий).

Показывает изменения, не внесенные в индекс:

>git diff

Изменения, внесенные в индекс:

>git diff --cached

Изменения в проекте по сравнению с последним коммитом:

>git diff HEAD

- **git branch — создание, перечисление и удаление веток**

Работа с ветками — очень легкая процедура в git, все необходимые механизмы сконцентрированы в одной команде.

Просто перечисляет существующие ветки, отметив активную:

>git branch

Создаёт новую ветку new-branch:

>git branch new-branch

Удаляет ветку, если та была залита (merged) с разрешением возможных конфликтов в текущую:

>git branch -d new-branch

Удаляет ветку в любом случае:

>git branch -D new-branch

Переименовывает ветку:

>git branch -m new-name-branch

Показывывает те ветки, среди предков которых есть определенный коммит:

>git branch --contains v1.2

Показывает коммит ответвления ветки new-name-branch от ветки master:

>git merge-base master new-name-branch

- **git checkout — переключение между ветками, извлечение файлов**
Команда git checkout позволяет переключаться между последними коммитами (если упрощенно) веток:

>git checkout some-other-branch

Создаёт ветку, в которую и произойдет переключение:

>git checkout -b some-other-new-branch

- **git merge — слияние веток, разрешение возможных конфликтов**
Слияние веток, в отличие от обычной практики централизованных систем, в git происходит практически каждый день. Естественно, что имеется удобный интерфейс к популярной операции.

Пытается объединить текующую ветку и ветку new-feature:

>git merge new-feature

- **Клонирование репозитория с подмодулями**
При клонировании репозитория вам необходимо инициализировать и обновить подмодули:

> $ git clone --recursive https://github.com/username/repo.git

## Ветки. Локальная работа с ветками в git.
- **Способы создания веток и переключения между ними**

Чтобы в Git добавить ветку мы используем:


> $ git branch <name of new branch>

После данной операции ветка уже была создана, но вы по-прежнему находитесь в прежней ветке. Если вы планируете переместиться на другую ветку, в том числе только что созданную, необходимо написать checkout:


> $ git checkout <name of branch>

Для того чтобы определить, где сейчас находится разработчик, Git использует специальный указатель HEAD, ссылающийся на текущую локальную ветку. В результате checkout HEAD переместится на иную ветку.

- **Как с помощью git branch создать ветку и перейти в нее**

Чаще всего при создании новой ветки git пользователю необходимо сразу же переключиться на нее. В таком случае стоит использовать:


> $ git checkout branch <name of new branch> 

Это будет равносильно:

>$ git branch <name of new branch>

>$ git checkout <name of new branch>


И также мы получим тот же результат при использовании git checkout с ключом -b:

>$ git checkout -b <name of branch>

Если пользователю нужно получить список определенного множества веток, то тогда можно воспользоваться ключами. Одними из самых распространенных будут:

>-r — при использовании этого ключа мы получим список удаленных веток,
>-a — используя этот параметр, в выводе будут удаленные и локальные ветки.

- **Основы ветвления и слияния**

Ветвление позволяет разделять рабочий процесс, оптимизировать тестирование и написание нового кода. Однако после того, как разработчик убедился, что написанный им кусок кода готов и его можно отправить к остальной части итоговой версии, удобно переместить его в основную ветку. Такой подход дает возможность получить к концу разработки проекта целый продукт в одном месте.
Для этого в Git предусмотрено слияние — перенос изменений с одной ветки на другую. Однако сливаемая ветка (под этим определением мы подразумеваем ветку, у которой берем изменения для «вливания» их в другую ветвь) никак не меняется и остается в прежнем состоянии. Такие преобразования мы получаем, применив **git merge**:

> $ git merge <name of merged branch>

Операция может привести к появлению конфликтов при попытке слить ветки. Это вызвано тем, что изменения удаляют или переписывают информацию в существующих файлах. При попытке некорректного слияния Git останавливает выполнение команды, чтобы вы могли разрешить конфликт.

Также стоит упомянуть о существовании ключей, предназначенных специально для работы с конфликтами:

— **abort** — прерывает слияние и возвращает все к началу
— **continue** — продолжает слияние после разрешения конфликта

Решить конфликт можно двумя способами:

-Вручную разрешить файловый конфликт. Для этого нужно самим изменить файлы, с которыми возникли проблемы. Мы получим файлы такими, какими и представляли их при попытке слияния.

-Выбрать более подходящий файл, а от второго отказаться.

- **Управление ветками с помощью git branch**

Эта команда может немного больше, чем просто в git создавать ветки из текущей. Если запустить ее без параметров:

>$ git branch

При выполнении этой строки мы получим список существующих веток, где символом * будет отмечена ветка, где вы сейчас находитесь. Это может выглядеть так:


 >first_branch
>* master
  second_branch

С помощью параметра -v можно получить последний сохраненный коммит в каждой ветке.

>$ git branch -v
  first_branch 8fa301b Fix math
>* master 225cc2d Merge branch 'first_branch'
  second_branch c56ee12 Refactor code style


Так же существуют опции —merged и —no-merged, с помощью которых можно отфильтровать полученную последовательность веток. То есть мы получим список ответвлений, которые уже были слиты, или, наоборот, ветки, которые еще не прошли через слияние с другими. Выведем ветки, которые уже были слиты с текущей:


>$ git branch --merged
  first_branch
>* master

- **Как закоммитить изменения в новую ветку**

После создания новой ветки, перехода в нее и совершения всех запланированных преобразований, нужно сделать коммит в эту же ветку, чтобы сохранить все изменения. Команды для выполнения этих действий ничем не отличаются от команд для создания коммитов в ветке мастер.

>$ git add

>$ git commit -m '<information about commit>'

- **Как запушить в новую ветку**

Если мы хотим запушить нашу ветку, то для этого нужно написать:

>$ git push origin <name of branch>

- **Как переименовать ветку**

В процессе разработки могут возникнуть ситуации, когда человек хочет по-другому называть уже созданную ветку. Это может быть связано с разными причинами (например, разрабатываемый в данной версии функционал не соответствует названию). Чтобы переименовать ветку применяем:

>$ git branch -m <new name of branch>

- **Как удалить ветку**

Удаление веток не такой простой процесс, как может показаться. Можно случайно удалить несохраненные изменения в исходном коде, что приведет к нежелательным последствиям. Поэтому здесь нужно действовать осторожно. С операцией удаления над ветками справляется уже привычная команда git branch с параметром -d:

>$ git branch -d <name of branch>

Для корректного удаления нужно помнить несколько правил, чтобы не получить ошибки:

Нельзя удалить ветку, в которой вы находитесь. Git выкинет ошибку и не произведет удаление. Следовательно, нужно перейти на другую ветку.
Git не позволит удалить ветку, у которой есть несохраненные изменения. Так мы избегаем ситуации, когда часть написанного кода будет безвозвратно утеряна. Если же мы уверены, что изменения в этой версии не нужны и их можно смело удалять, то вместо флага -d используем -D:

>$ git branch -D <name of branch>

Соблюдая все условия, нам удастся удалить указанную ветвь.

- **Как просмотреть состояния файлов ветки**

Отметим, что при переходе на другую версию, незакоммиченные изменения перенесутся на ветку, куда мы перейдем. Поэтому перед переключением необходимо убедиться, что изменения в текущей ветки уже закоммичены. Для этого подходит git status:

>$ git status

- **Как просмотреть истории коммитов ветки**

Неоднократно в процессе разработки нужно посмотреть на журнал изменений: для отслеживания развития проекта или для определения коммита, к которому следует вернуться. В таких ситуациях выручает команда git log:

>$ git log <keys> --<path>

У данной команды есть множество ключей, используя которые можно получить более конкретную информацию:

-**- < number >** (равноценно -n=<number>) — показывает последние n коммитов,

—**pretty**=<value> (доступные такие значения, как oneline, short, medium, full и другие) ****— форматированный вывод истории,

**-p** — выводятся изменения, содержащиеся в коммите,

**—graph** — представляет дерево взаимосвязей коммитов в виде ASCII-графа — такой метод использования позволяет получить графическое представление ветвей прямо в консоли,

**—all** — на выходе мы получаем историю всех коммитов для всех существующих веток,
—decorate — показывает, на что ссылаются указатели

Если нам нужно посмотреть историю для конкретной ветви, то поможет выполнение:

>$ git log <keys> <name of parent's branch>..<name of branch>

- **Как просмотреть различия между коммитами**

Достаточно часто в ходе разработки какого-либо продукта у разработчика может возникнуть потребность посмотреть разницу между двумя коммитами, прежде чем заливать что-то. Для этого существует git diff:

>$ git diff <keys> <path to file> <path to file>

Для этой операции также предусмотрены несколько ключей:

**—diff**-filter=< mark > — с помощью этого параметра, изменяя значения меток, можно задать, обновления между какими файлами мы хотим увидеть. Рассмотрим некоторые возможные значения меток:

**D** — покажет удаленные файлы,
**M** — мы получим файлы, модифицированные после последнего коммита.
**—word**-diff=color — повышает читабельность полученной информации: слова подсвечиваются зеленым цветом, если они были добавлены, и красным — если были удалены.

### Что такое ветки и для чего они нужны при работе с системой контроля версий.

**Ветка в Git** — это набор коммитов, расположенных в хронологическом порядке. У каждой ветки есть свое название. Основная ветка чаще всего называется master, она появляется при инициализации репозитория и считается главной веткой проекта. Другим веткам вы даете имена самостоятельно. Дополнительные ветки используются для создания нового функционала и исправления ошибок.

Ветки позволяют командам разработчиков без труда вести совместную работу с одной централизованной базой кода. Когда разработчик создает ветку, система контроля версий создает копию базы кода, актуальную на текущий момент времени. Изменения ветки не влияют на работу других разработчиков в команде.

### Базовая работа с ветками в git.
- **Для работы с ветками в Git можно использовать следующие команды:**

1. git branch — перечисляет существующие ветки, отметив активную.

2. git branch new-branch — создаёт новую ветку new-branch.

3. git branch -d new-branch — удаляет ветку, если она была залита (merged) с разрешением возможных конфликтов в текущую.

4. git branch -D new-branch — удаляет ветку в любом случае.

5. git branch -m new-name-branch — переименовывает ветку.

6. git branch --contains v1.2 — показывает те ветки, среди предков которых есть определённый коммит.

7. git merge-base master new-name-branch — показывает коммит ответвления ветки new-name-branch от ветки master.

8. git checkout — позволяет переключаться между ветками, извлекать файлы.

9. git cherry-pick — применяет к дереву проекта изменения, внесённые отдельным коммитом.

10. git worktree — позволяет работать одновременно с несколькими ветками одного репозитория.


## Работа с удаленными репозиториями.
- **Основы работы с удаленным репозиторием Git**

Просмотр удаленного репозитория
Для того чтобы просмотреть список названий удаленных репозиториев, которые были добавлены, используйте команду:

>git remote

Указав ключ -v, можно просмотреть, какие адреса в добавленных удаленных репозиториях используются для чтения и записи.

Полный список удаленных ссылок можно получить с помощью команды:

>git ls-remote <remote>

Либо для получения удаленных веток и дополнительной информации используйте команду:

>git remote show <remote>

**< remote >** — название удаленного репозитория, которое ему дали после подключения. Можно использовать и url интересующего удаленного репозитория.

- **Изменение удаленного репозитория**

Чтобы отправить изменения (имя ветки) <branch-name> на сервер <remote-name>, задействуйте команду:

>git push <remote-name> <branch-name>

Если ветка, которую вы хотите отправить, не отслеживается, то добавьте флаг —set-upstream. На примере ветки develop это будет выглядеть вот так:

>git push --set-upstream origin develop

- **Получение изменений из удаленного репозитория**
Для связи с указанным удаленным репозиторием используется следующая команда, которая подтянет новые изменения на локальный репозиторий:

>git fetch [remote-name]

Если ветка настроена на отслеживание удаленной ветки, то можно использовать более удобную команду:

>git pull 

Данная команда заменяет прописывание двух команд:

>git fetch; git merge

Есть и универсальнее способ: клонирование репозитория. Клонирование копирует все файлы и коммиты удаленного репозитория, после чего уже можно использовать предыдущую команду — git fetch, если понадобятся новые изменения из удаленного репозитория.

>git clone [url]

### Что такое удаленный репозиторий и для чего он нужен
**Удаленный репозиторий** – это репозиторий, размещенный в локальной или интернет сети. Удаленный репозиторий используется для того, чтобы делиться и обмениваться кодом между разработчиками в рамках сети. Его также можно использовать, если вы разрабатываете проект на нескольких устройствах.

- **Удаленный репозиторий, зачем он нужен**

Это репозиторий, который хранится в облаке, на сторонних сервисах, специально созданных под работу с проектами git.

Плюсы удаленного репозитория

- выполняет роль резервной копии
- возможность работать в команде
- некоторые дополнительные возможности, которые предоставляет хостинг. Например, визуализация истории или возможность работать над проектом прямо в веб-интерфейсе

### Базовая работа с удаленными репозиториями GitHub
- **Подключение к удаленному репозиторию**

Чтобы загрузить что-нибудь в удаленный репозиторий, сначала нужно к нему подключиться. Регистрация и установка может занять время, но все подобные сервисы предоставляют хорошую документацию.
Чтобы связать наш локальный репозиторий с репозиторием на GitHub, выполним следующую команду в терминале. Обратите внимание, что нужно обязательно изменить URI репозитория на свой.

#### This is only an example. Replace the URI with your own repository address.
$ git remote add origin https://github.com/tutorialzine/awesome-project.git
Проект может иметь несколько удаленных репозиториев одновременно. Чтобы их различать, мы дадим им разные имена. Обычно главный репозиторий называется origi

Отправка изменений на сервер
Сейчас самое время переслать наш локальный коммит на сервер. Этот процесс происходит каждый раз, когда мы хотим обновить данные в удаленном репозитории.
Команда, предназначенная для этого - push. Она принимает два параметра: имя удаленного репозитория (мы назвали наш origin) и ветку, в которую необходимо внести изменения (master — это ветка по умолчанию для всех репозиториев).

>$ git push origin master
>Counting objects: 3, done.
>Writing objects: 100% (3/3), 212 bytes | 0 bytes/s, done.
>Total 3 (delta 0), reused 0 (delta 0)
>To https://github.com/tutorialzine/awesome-project.git
>* [new branch] master -> master

Эта команда немного похожа на git fetch, с той лишь разницей, что при помощи fetch мы импортируем коммиты в локальную ветку, а применив push, мы экспортируем их из локальной в удаленную. Если вам необходимо настроить удаленную ветку используйте git remote. Однако пушить надо осторожно, ведь рассматриваемая команда перезаписывает безвозвратно все изменения. В большинстве случаев, ее используют, чтобы опубликовать выгружаемые локальные изменения в центральный репозиторий. А еще ее применяют для того, чтобы поделиться, внесенными в локальный репозиторий, нововведениями, с коллегами или другими удаленными участниками разработки проекта. Подытожив сказанное, можно назвать git push - командой выгрузки, а git pull и git fetch - командами загрузки или скачивания. После того как вы успешно запушили измененные данные, их необходимо внедрить или интегрировать, при помощи команды слияния git merge.
В зависимости от сервиса, который вы используете, вам может потребоваться аутентифицироваться, чтобы изменения отправились. Если все сделано правильно, то когда вы посмотрите в удаленный репозиторий при помощи браузера, вы увидите файл hello.txt

- **Запрос изменений с сервера** 

Если вы сделали изменения в вашем удаленном репозитории, другие пользователи могут скачать изменения при помощи команды pull.

>$ git pull origin master
>From https://github.com/tutorialzine/awesome-project
>* branch master -> FETCH_HEAD
>Already up-to-date.

Так как новых коммитов с тех пор, как мы склонировали себе проект, не было, никаких изменений доступных для скачивания нет.

- **Как удалить локальный репозиторий**

Вам не понравился один из ваших локальных Git-репозиториев и вы хотите стереть его со своей машины. Для этого вам всего лишь надо удалить скрытую папку «.git» в корневом каталоге репозитория. Сделать это можно 3 способами:

Проще всего вручную удалить эту папку «.git» в корневом каталоге «Git Local Warehouse».
Также удалить, не устраивающий вас, репозиторий можно на github. Открываете нужный вам объект и переходите в пункт меню Настройки. Там, прокрутив ползунок вниз, вы попадете в зону опасности, где один из пунктов будет называться «удаление этого хранилища».
Последний метод удаления локального хранилища через командную строку, для этого в терминале необходимо ввести следующую команду:

>cd repository-path/
>rm -r .git


## Совместная работа над проектом (fork, pull request)
- **Порядок действий**

1. Разработчик делает форк «официального» репозитория, расположенного на сервере, и в результате получает собственную копию репозитория на сервере.

2. Разработчик клонирует созданную копию на сервере в локальную систему.

3. В локальный клон добавляется удаленный путь к «официальному» репозиторию Git.

4. Создается новая локальная функциональная ветка.

5. Разработчик вносит изменения в новую ветку.

6. Для изменений создаются новые коммиты.

7. Разработчик отправляет ветку в собственную копию репозитория на сервере.

8. Разработчик открывает запрос pull для переноса кода из новой ветки в «официальный» репозиторий.

9. Запрос pull на слияние подтверждается, после чего выполняется слияние с исходным репозиторием на сервере.

Чтобы интегрировать функцию в официальную базу кода, пользователь, ответственный за поддержку проекта, помещает изменения автора в свой локальный репозиторий, проверяет, не нарушают ли они работу проекта, выполняет их слияние со своей локальной главной веткой (main), после чего отправляет main ветку в официальный репозиторий на сервере. После этого поступивший код становится частью проекта, и другие разработчики должны получить его из официального репозитория, чтобы синхронизировать свои локальные репозитории.

Важно понимать, что понятие «официальный репозиторий» в рабочем процессе с форками — простая условность. Официальным его можно назвать лишь по той причине, что он выступает публичным репозиторием пользователя, ответственного за поддержку проекта.

- **Сравнение создания форков и клонирования**

Важно отметить, что репозитории с форками и создание форков не требуют специальных операций. Форки репозиториев создаются стандартной командой git clone. В большинстве случаев форки репозиториев являются «клонами на сервере», а для их размещения и управления ими обычно используют сторонний сервис Git, такой как Bitbucket. Отдельной команды Git для создания форков репозиториев не существует. При клонировании, по сути, происходит копирование репозитория и его истории.

- **Ветвление в рабочем процессе с форками**

Собственные публичные репозитории — это просто удобный способ поделиться ветками с другими разработчиками. Пользователям все равно следует отделять функции с помощью веток, как это происходит в рабочем процессе с функциональными ветками и в Git-flow. Разница заключается лишь в том, как этими ветками можно поделиться. В рабочем процессе с форками их помещают в локальный репозиторий другого разработчика, а в рабочих процессах с функциональными ветками и Git-flow — в официальный репозиторий.

- **Форк репозитория**

В проекте, где используется рабочий процесс с форками, каждому новому разработчику нужно создать форк официального репозитория. Как уже говорилось ранее, создание форка — это обычная операция git clone. Для создания форка нужно установить SSH-соединение с сервером и выполнить команду git clone, чтобы скопировать репозиторий в другое место на сервере. В популярных сервисах размещения Git, таких как Bitbucket, предусмотрены функции создания форков репозитория, с помощью которых можно автоматизировать этот шаг.

- **Клонирование форка**
В проекте, где используется рабочий процесс с форками, каждому новому разработчику нужно создать форк официального репозитория. Как уже говорилось ранее, создание форка — это обычная операция git clone. Для создания форка нужно установить SSH-соединение с сервером и выполнить команду git clone, чтобы скопировать репозиторий в другое место на сервере. В популярных сервисах размещения Git, таких как Bitbucket, предусмотрены функции создания форков репозитория, с помощью которых можно автоматизировать этот шаг.

Если для размещения таких репозиториев используется Bitbucket, разработчику, занятому в проекте, потребуется создать аккаунт Bitbucket и клонировать свой форк репозитория с помощью следующей команды:

>git clone https://user@bitbucket.org/user/repo.git

- **Добавление удаленного подключения**

В то время как в других рабочих процессах Git используется одно удаленное подключение, которое указывает на центральный репозиторий, рабочему процессу с форками требуется связь с официальным репозиторием и личным репозиторием разработчика на сервере. Хотя эти удаленные подключения можно назвать как угодно, обычно подключение к форку репозитория называется origin (создается автоматически при выполнении команды git clone), а подключение к официальному репозиторию — upstream.

>git remote add upstream https://bitbucket.org/maintainer/repo

Вам потребуется самостоятельно создать удаленное подключение upstream с помощью указанной выше команды. Это позволит вам без труда поддерживать актуальность локального репозитория по мере выполнения официального проекта. Обратите внимание: если в вышестоящем (upstream) репозитории включена аутентификация (т. е. он не является репозиторием открытого исходного кода), вам нужно будет указать имя пользователя, например:

>git remote add upstream https://user@bitbucket.org/maintainer/repo.git

При этом перед клонированием или получением изменений из официальной базы кода пользователь должен будет указать действительный пароль.

- **Работа в ветке: внесение и отправка изменений** 

В локальной копии форка репозитория разработчик может редактировать код, делать коммиты изменений и создавать ветки так же, как и в других рабочих процессах Git:

>git checkout -b some-feature # Edit some code git commit -a -m "Add first draft of some feature"
Все изменения будут полностью закрытыми, пока разработчик не отправит их в свой публичный репозиторий. А если кто-то внес изменения в официальный проект, можно получить доступ к новым коммитам с помощью команды git pull:

>git pull upstream main

- **Выполнение пул-реквеста**

Когда разработчик готов поделиться новой функцией, ему нужно сделать две вещи. Во-первых, он должен открыть другим разработчикам доступ к своему коду, поместив его в свой публичный репозиторий. Поскольку удаленное подключение origin, скорее всего, уже настроено, ему остается только выполнить следующую команду:

> git push origin feature-branch

В отличие от других рабочих процессов, здесь удаленное подключение origin указывает на личный репозиторий разработчика на сервере, а не на основную базу кода.

Во-вторых, разработчик должен сообщить пользователю, ответственному за поддержку проекта, что он хочет выполнить слияние функции с официальной базой кода. В Bitbucket имеется кнопка запроса pull, при нажатии которой появляется форма, в которой нужно указать ветку для ее слияния с официальным репозиторием. Как правило, разработчику нужно интегрировать свою функциональную ветку в главную ветку вышестоящего (upstream) удаленного репозитория.

- **Резюме**
Напомним, что рабочий процесс с форками обычно используется в публичных проектах с открытым исходным кодом. Форк создают с помощью операции git clone с участием серверной копии репозитория проекта. Рабочий процесс с форками часто используется в сочетании с сервисом размещения Git, например Bitbucket. Вот общий пример рабочего процесса с форками:

1. Вы хотите включить свой код в библиотеку с открытым исходным кодом, размещенную по адресу bitbucket.org/userA/open-project

2. С помощью Bitbucket вы создаете форк репозитория по адресу bitbucket.org/YourName/open-project

3. В локальной системе вы выполняете команду git clone для https://bitbucket.org/YourName/open-project, чтобы получить локальную копию репозитория

4. Вы создаете новую функциональную ветку в локальном репозитории

5. Вы создаете новую функцию и выполняете команду git commit для сохранения изменений

6. Затем вы отправляете новую функциональную ветку в свой удаленный форк репозитория

7. С помощью Bitbucket вы открываете запрос pull для слияния новой ветки с исходным репозиторием по адресу bitbucket.org/userA/open-project

Рабочий процесс с форками помогает пользователю, ответственному за поддержку проекта, открыть репозиторий и начать принимать код от любых разработчиков. При этом ему не приходится вручную управлять настройками авторизации каждого отдельного автора. Он использует рабочий процесс в стиле pull. Чаще всего рабочий процесс с форками используется в проектах с открытым исходным кодом, однако его можно применять и в рабочих процессах частного бизнеса, чтобы обеспечить строгий контроль над слиянием с веткой релиза. Он может быть полезен командам, которые используют диспетчеры развертывания или имеют четкие циклы релизов.

### Как строится и для чего нужна совместная работа в системах контроля версий
Взаимодействие просто представляет собой синхронизацию локального и удаленного репозиториев. Копирование данных из локального репозитория в удаленный в данной системе контроля версий осуществляется командой push, а обратный процесс – командой pull. Любые изменения в документе и его новые версии сохраняются в локальном репозитории. Набор всех сохраненных версий называют «деревом» проекта, и оно находится в репозитории.

Работа в системе контроля версий дает возможность сохранять промежуточные варианты проекта, плюс это еще и помогает справляться с проблемами в случае их возникновения. Когда, например, несколько программистов, работающих над одной опцией, одновременно сбросят в репозиторий созданные версии, то система в автоматическом режиме займется устранением конфликта.

### Инструкция по созданию pull request
Для создания pull request выполните следующие шаги:

1. Найдите на экране вкладку «Pull request».

2. Кликните по кнопке «New pull request».

3. Выберите ветку, которую хотите сравнить с веткой «Master».

4. Сравните ветку с мастером, чтобы увидеть список всех изменений.

5. Кликните на кнопку «Create pull request».

6. Поясните pull request и снова кликните на кнопку «Create pull request».

Владелец репозитория увидит pull request и сможет принять меры для его объединения.

## Книги и полезные ссылки по изучению git.
- **Книги:**

1. Ben Lynn - "Git Magic"

2. Скотт Шакон - Pro Git

- **Ссылки**

1. https://docs.github.com/ru/get-started/using-git/about-git

2. https://translated.turbopages.org/proxy_u/en-ru.ru.5d540812-66299002-052b4b49-74722d776562/https/www.freecodecamp.org/news/create-and-sync-git-and-github-repositories/?__ya_mt_enable_static_translations=1

## Альтернативные системы контроля версий.
**GitFlic** — первый российский облачный сервис для разработки и обслуживания исходного кода программ.

**Gitee** — китайский сервис, которым пользуются более 5 млн разработчиков и более 100 тыс. компаний.

**Gogs** — продукт китайской разработки, похожий на GitHub по дизайну.

**RhodeCode** — система управления репозиториями немецкой компании.

**Launchpad** — платформа для запуска и управления проектами, созданная британской компанией Canonical.

### Итак, какая система контроля версий подойдет для вашего проекта?
Для моего проекта лучше всего подходит Git. Так как Git это единственное что мы изучили за короткий период обучения, он все равно более удобен. Git более распространен среди программистов, соответсвено улучшается с каждым разом и становится лучше.

# Система одновременных версий (CVS)
- **CVS (англ. Concurrent Versions System  — система одновременных версий)** — централизованная система управления версиями, популярная в 1990-е — начале 2000-х годов. Хранит историю изменений определённого набора файлов, как правило, исходного кода программного обеспечения, и облегчает совместную работу группы людей над одним проектом. Распространяется на условиях лицензии GNU GPL.

# Apache Subversion (SVN)
- **Apache Subversion (часто аббревиатура SVN, по названию команды svn)** — система управления версиями программного обеспечения, распространяемая с открытым исходным кодом под лицензией Apache. [2] Разработчики программного обеспечения используют Subversion для поддержки текущих и исторических версий файлов, таких как исходный код, веб-страницы и документация. Его цель - быть в основном совместимым преемником широко используемой системы параллельных версий (CVS).

Сообщество разработчиков ПО с открытым исходным кодом широко использовало Subversion: например, в таких проектах, как Apache Software Foundation, FreeBSD, SourceForge, а с 2006 по 2019 год — GCC. CodePlex ранее был общим хостом для репозиториев Subversion.

Subversion был создан CollabNet Inc. в 2000 году и в настоящее время является проектом верхнего уровня Apache, созданным и используемым глобальным сообществом участников. 

# Добавил заключение
- **GitHub** — это многофункциональная платформа для командной работы над проектом, состоящая из:
 - облачного хранилища, в котором размещаются все файлы;
- социальной сети для разработчиков;
- системы контроля версий, фиксирующей все редакции, вносимые в код тем или иным участником.

Простыми словами Гитхаб — площадка, где можно разместить общий проект, совместно управлять всеми изменениями, а в случае неудачи — быстро вернуться к исправной версии. О возможностях GitHub рассказываем в нашем обзоре.
